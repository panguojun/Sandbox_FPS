using UnityEngine;using System.IO;using System.Collections;public class LoadMesh : MonoBehaviour{	public GameObject sceneroot;    public ParticleSystem PS;    public GameObject ROCK;    public GameObject HPLANT;    public GameObject Araceae;    public GameObject Building;    public GameObject BAMBOO;    public GameObject LOTUS;    public GameObject GRASS;    public GameObject WATER;    public GameObject MUD;    public GameObject SONGBAI;    public GameObject DONGQING;    public GameObject PENQUAN;    public GameObject TriangleArt;    public GameObject Triangle3DArt;    public GameObject DASHU;	public GameObject ROADLIGHT;    public GameObject MAGICCUBE;    public static bool bnewcreated = true;    float loadtime = 0;    bool bReadEnvironment = false;    public GameObject getObjByName(string nm)    {        if (nm.Contains("ROCK")) return ROCK;        if (nm.Contains("HPLANT")) return HPLANT;        if (nm.Contains("Araceae")) return Araceae;        if (nm.Contains("Building")) return Building;        if (nm.Contains("BAMBOO")) return BAMBOO;        if (nm.Contains("LOTUS")) return LOTUS;        if (nm.Contains("GrassTmp")) return GRASS;        if (nm.Contains("WATER")) return WATER;        if (nm.Contains("MUD")) return MUD;        if (nm.Contains("SONGBAI")) return SONGBAI;        if (nm.Contains("DONGQING")) return DONGQING;        if (nm.Contains("PENQUAN")) return PENQUAN;        if (nm.Contains("TriangleArt")) return TriangleArt;        if (nm.Contains("Triangle3DArt")) return Triangle3DArt;        if (nm.Contains("DASHU")) return DASHU;        if (nm.Contains("ROADLIGHT")) return ROADLIGHT;        if (nm.Contains("MagicCube")) return MAGICCUBE;        return null;    }    void loadobjs()    {                string filepath = Application.dataPath + @"/StreamingAssets/" + Common.sceneName + "/scene.sv";        Debug.Log("loadobjs: " + filepath);        if (File.Exists(filepath))        {            bnewcreated = false;            FileStream fs = new FileStream(filepath, FileMode.Open);            BinaryReader br = new BinaryReader(fs);            int index = 0;            byte[] tempall = br.ReadBytes((int)fs.Length);            while (true)            {                //当超过流长度，跳出循环                if (index >= tempall.Length)                {                    break;                }                 int objectLength = tempall[index]; index += 1;                byte[] objectName = new byte[objectLength];                               System.Array.Copy(tempall, index, objectName, 0, objectName.Length); index += objectName.Length;                string oname = System.Text.Encoding.Default.GetString(objectName);               // Debug.Log("read obj: " + oname);                                byte[] buf4 = new byte[4];                System.Array.Copy(tempall, index, buf4, 0, buf4.Length); index += buf4.Length;                float x = System.BitConverter.ToSingle(buf4, 0);                System.Array.Copy(tempall, index, buf4, 0, buf4.Length); index += buf4.Length;                float y = System.BitConverter.ToSingle(buf4, 0);                                System.Array.Copy(tempall, index, buf4, 0, buf4.Length); index += buf4.Length;                float z = System.BitConverter.ToSingle(buf4, 0);                                System.Array.Copy(tempall, index, buf4, 0, buf4.Length); index += buf4.Length;                float rx = System.BitConverter.ToSingle(buf4, 0);                                System.Array.Copy(tempall, index, buf4, 0, buf4.Length); index += buf4.Length;                float ry = System.BitConverter.ToSingle(buf4, 0);                                System.Array.Copy(tempall, index, buf4, 0, buf4.Length); index += buf4.Length;                float rz = System.BitConverter.ToSingle(buf4, 0);                                System.Array.Copy(tempall, index, buf4, 0, buf4.Length); index += buf4.Length;                float sx = System.BitConverter.ToSingle(buf4, 0);                                                System.Array.Copy(tempall, index, buf4, 0, buf4.Length); index += buf4.Length;                float sy = System.BitConverter.ToSingle(buf4, 0);                                System.Array.Copy(tempall, index, buf4, 0, buf4.Length); index += buf4.Length;                float sz = System.BitConverter.ToSingle(buf4, 0);                               {                    //最后在这里把场景生成出来                                       Vector3 pos = new Vector3(x, y, z);                    Vector3 rot = new Vector3(rx, ry, rz);                   // Vector3 sca = new Vector3(sx, sy, sz);                    GameObject tmp = getObjByName(oname);                                       if (tmp)                    {                        GameObject ob = (GameObject)Instantiate(tmp, pos, Quaternion.Euler(rot));                        ob.name = oname;                                               // ob.transform.localScale = sca;                        if (ob.name.Contains("Building"))                        {// 加载mesh                            ((MeshCreator)ob.GetComponent(typeof(MeshCreator))).meshtype = -1; // 不要擅自创建                            MeshFilter mf = ob.GetComponent<MeshFilter>();                            if (readMesh(mf.mesh, ob.name))                            {                                MeshCollider mc = (MeshCollider)ob.GetComponent<MeshCollider>();                                if (mc)                                    mc.sharedMesh = mf.mesh;                            }                                                    }                        else if (ob.name.Contains("WATER"))                        {                            ob.transform.localScale = new Vector3(sx, sy, sz);                            MeshFilter mf = ob.GetComponent<MeshFilter>();                            if (readMesh(mf.mesh, ob.name))                            {                                MeshCollider mc = (MeshCollider)ob.GetComponent<MeshCollider>();                                if (mc)                                    mc.sharedMesh = mf.mesh;                            }                        }                        else if (ob.name.Contains("MUD"))                        {                            ob.transform.localScale = new Vector3(sx, sy, sz);                            MeshFilter mf = ob.GetComponent<MeshFilter>();                            if (readMesh(mf.mesh, ob.name))                            {                                MeshCollider mc = (MeshCollider)ob.GetComponent<MeshCollider>();                                if (mc)                                    mc.sharedMesh = mf.mesh;                            }                        }                         else if (ob.name.Contains("TriangleArt"))                        {// 加载mesh                            ((MeshCreator)ob.GetComponent(typeof(MeshCreator))).meshtype = -1; // 不要擅自创建                            MeshFilter mf = ob.GetComponent<MeshFilter>();                            if (readMesh(mf.mesh, ob.name))                            {                                MeshCollider mc = (MeshCollider)ob.GetComponent<MeshCollider>();                                if (mc)                                    mc.sharedMesh = mf.mesh;                            }                        }                        else if (ob.name.Contains("Triangle3DArt"))                        {// 加载mesh                            ((MeshCreator)ob.GetComponent(typeof(MeshCreator))).meshtype = -1; // 不要擅自创建                            MeshFilter mf = ob.GetComponent<MeshFilter>();                            if (readMesh(mf.mesh, ob.name))                            {                                MeshCollider mc = (MeshCollider)ob.GetComponent<MeshCollider>();                                if (mc)                                    mc.sharedMesh = mf.mesh;                            }                        }                        ob.SetActive(true);						ob.transform.SetParent(sceneroot.transform);                       // Debug.Log("create obj: " + oname);                    }                }            }            br.Close();            fs.Close();        }        loadtime = Time.time;    }        static Color32 FromInt(int value)    {        Color32 cor = new Color32(0,0,0,0);        cor.a = (byte)(0xFF & (value >> 24));        cor.b = (byte)(0xFF & (value >> 16));        cor.g = (byte)(0xFF & (value >> 8));        cor.r = (byte)(0xFF & value);        return cor;    }    void saveObjs()    {        string filepath = Application.dataPath + @"/StreamingAssets/" + Common.sceneName;        Debug.Log("saveFolder " + filepath);        if (!Directory.Exists(filepath))        {// 文件夹                        Directory.CreateDirectory(filepath);        }        filepath += "/scene.sv";        Debug.Log("saveObjs " + filepath);        if (File.Exists(filepath))        {// 文件            File.Delete(filepath);        }        FileStream fs = new FileStream(filepath, FileMode.Create);        BinaryWriter bw = new BinaryWriter(fs);               foreach (GameObject obj in GameObject.FindObjectsOfType(typeof(GameObject)))        {            if (obj.transform.parent == sceneroot.transform                 && obj.name != "MOON"				 && obj.name != "Asteroid"                )            {                Debug.Log("save obj: " + obj.name);                bw.Write(obj.name);                                bw.Write(obj.transform.position.x);                bw.Write((obj.transform.position.y));                bw.Write((obj.transform.position.z));                bw.Write((obj.transform.rotation.eulerAngles.x));                bw.Write((obj.transform.rotation.eulerAngles.y));                bw.Write((obj.transform.rotation.eulerAngles.z));                bw.Write((obj.transform.localScale.x));                bw.Write((obj.transform.localScale.y));                bw.Write((obj.transform.localScale.z));                if(obj.name.Contains("Building"))                {                    MeshFilter mf = obj.gameObject.GetComponent<MeshFilter>();                    saveMesh(mf.mesh, obj.name);                  }                else if (obj.name.Contains("WATER"))                {                    MeshFilter mf = obj.gameObject.GetComponent<MeshFilter>();                    saveMesh(mf.mesh, obj.name);                }                else if (obj.name.Contains("MUD"))                {                    MeshFilter mf = obj.gameObject.GetComponent<MeshFilter>();                    saveMesh(mf.mesh, obj.name);                }                else if(obj.name.Contains("TriangleArt"))                {                    MeshFilter mf = obj.gameObject.GetComponent<MeshFilter>();                    saveMesh(mf.mesh, obj.name);                }                else if (obj.name.Contains("Triangle3DArt"))                {                    MeshFilter mf = obj.gameObject.GetComponent<MeshFilter>();                    saveMesh(mf.mesh, obj.name);                }            }        }        bw.Flush();        bw.Close();        fs.Close();    }    // ------------------------------------------------    static bool readMesh(Mesh m, string name)    {        Debug.Log("readMesh " + name);        string filepath = Application.dataPath + @"/StreamingAssets/" + Common.sceneName + "/" +  name + ".mesh";        if (File.Exists(filepath))        {            FileStream fs = new FileStream(filepath, FileMode.Open);            BinaryReader br = new BinaryReader(fs);            int index = 0;            //将二进制字节流全部读取在这个byte数组当中            //ReadBytes传递的参数是一个长度，也就是流的长度            byte[] tempall = br.ReadBytes((int)fs.Length);            m.Clear();            //开始解析这个字节数组            while (true)            {                //当超过流长度，跳出循环                if (index >= tempall.Length)                    break;                //得到第一个byte 也就是得到字符串的长度                byte[] tposx = new byte[4];                {// 顶点                    System.Array.Copy(tempall, index, tposx, 0, tposx.Length); index += tposx.Length;                    int vertexCount = System.BitConverter.ToInt32(tposx, 0);                    Debug.Log("vertexCount = " + vertexCount.ToString());                    if (vertexCount >= 65000)                    {                        Debug.Log("vertexCount >= 65000");                        break;                    }                    Vector3[] vertices = new Vector3[vertexCount];                    for (int i = 0; i < vertexCount; i++)                    {                        System.Array.Copy(tempall, index, tposx, 0, tposx.Length); index += tposx.Length;                        vertices[i].x = System.BitConverter.ToSingle(tposx, 0);                        System.Array.Copy(tempall, index, tposx, 0, tposx.Length); index += tposx.Length;                        vertices[i].y = System.BitConverter.ToSingle(tposx, 0);                        System.Array.Copy(tempall, index, tposx, 0, tposx.Length); index += tposx.Length;                        vertices[i].z = System.BitConverter.ToSingle(tposx, 0);                        // Debug.Log("ver: " + vertices[i].ToString());                    }                    m.vertices = vertices;                }                {// 顶点色                    System.Array.Copy(tempall, index, tposx, 0, tposx.Length); index += tposx.Length;                    int vertexCount = System.BitConverter.ToInt32(tposx, 0);                    //Debug.Log("vertexCount = " + vertexCount.ToString());                    if (vertexCount >= 65000)                    {                        Debug.Log("vertexCount >= 65000");                        break;                    }                    Color32[] colors = new Color32[vertexCount];                    for (int i = 0; i < vertexCount; i++)                    {                        System.Array.Copy(tempall, index, tposx, 0, tposx.Length); index += tposx.Length;                        colors[i] = FromInt(System.BitConverter.ToInt32(tposx, 0));                                                                    }                    m.colors32 = colors;                }                {// 三角形                    System.Array.Copy(tempall, index, tposx, 0, tposx.Length); index += tposx.Length;                    int triangleCount = System.BitConverter.ToInt32(tposx, 0);                    //int triangleCount = tempall[index]; index += 4;                    //Debug.Log("triangleCount = " + triangleCount.ToString());                    if (triangleCount >= 250000)                    {                        Debug.Log("triangleCount >= 250000");                        break;                    }                    int[] triangles = new int[triangleCount];                    for (int i = 0; i < triangleCount; i++)                    {                        System.Array.Copy(tempall, index, tposx, 0, tposx.Length); index += tposx.Length;                        triangles[i] = System.BitConverter.ToInt32(tposx, 0);                        // Debug.Log("tri: " + triangles[i].ToString());                    }                    m.triangles = triangles;                }                                m.RecalculateBounds();                m.RecalculateNormals();                break;            }            br.Close();            fs.Close();            return true;        }        return false;    }    static void saveMesh(Mesh m, string name)    {                string filepath = Application.dataPath + @"/StreamingAssets/" + Common.sceneName + "/" + name + ".mesh";        if (File.Exists(filepath))        {            File.Delete(filepath);        }        FileStream fs = new FileStream(filepath, FileMode.Create);        BinaryWriter bw = new BinaryWriter(fs);          {            bw.Write(m.vertexCount);                        // Debug.Log("vertexCount = " + m.vertexCount.ToString());            byte[] tposx = new byte[4 * 3 * m.vertexCount];            PMDLL.converVecs2Bytes(m.vertices, tposx, 4 * 3 * m.vertexCount);                        bw.Write(tposx);        }        {            bw.Write(m.vertexCount);            // Debug.Log("vertexCount = " + m.vertexCount.ToString());            byte[] tposx = new byte[4 * m.vertexCount];            PMDLL.converCors2Bytes(m.colors32, tposx, 4 * m.vertexCount);            bw.Write(tposx);        }        {            bw.Write(m.triangles.Length);            // Debug.Log("triangleCount = " + m.triangles.Length.ToString());            byte[] tposx = new byte[4 * m.triangles.Length];            PMDLL.converInts2Bytes(m.triangles, tposx, 4 * m.triangles.Length);            bw.Write(tposx);        }        bw.Flush();        bw.Close();        fs.Close();    }    //static void export3DS(Mesh m, string name)    //{    //    string filepath = Application.dataPath + @"/StreamingAssets/" + Common.sceneName + "/" + name + ".mesh";    //    if (File.Exists(filepath))    //    {    //        File.Delete(filepath);    //    }    //    FileStream fs = new FileStream(filepath, FileMode.Create);    //    StringWriter bw = new StringWriter(fs);    //    {    //        bw.Write("o Submesh\n");    //        for(int i = 0; i < )    //        "v " << v.x << " " << v.y << " " << v.z << "\n";    //        bw.Write(m.vertexCount);    //        // Debug.Log("vertexCount = " + m.vertexCount.ToString());    //        byte[] tposx = new byte[4 * 3 * m.vertexCount];    //        PMDLL.converVecs2Bytes(m.vertices, tposx, 4 * 3 * m.vertexCount);    //        bw.Write(tposx);    //    }    //    bw.Flush();    //    bw.Close();    //    fs.Close();    //}    static void readEnvironment(ParticleSystem ps)    {        string filepath = Application.dataPath + @"/StreamingAssets/" + Common.sceneName + "/environment.ev";        Debug.Log("readEnvironment: " + filepath);        if (File.Exists(filepath))        {            bnewcreated = false;            FileStream fs = new FileStream(filepath, FileMode.Open);            BinaryReader br = new BinaryReader(fs);            int index = 0;            byte[] tempall = br.ReadBytes((int)fs.Length);            ParticleSystem.Particle[] ptcs = new ParticleSystem.Particle[10];            ps.GetParticles(ptcs);            int pind = 0;            while (true)            {                //当超过流长度，跳出循环                if (index >= tempall.Length)                {                    break;                }                byte[] buf4 = new byte[4];                System.Array.Copy(tempall, index, buf4, 0, buf4.Length); index += buf4.Length;                float x = System.BitConverter.ToSingle(buf4, 0);                System.Array.Copy(tempall, index, buf4, 0, buf4.Length); index += buf4.Length;                float y = System.BitConverter.ToSingle(buf4, 0);                System.Array.Copy(tempall, index, buf4, 0, buf4.Length); index += buf4.Length;                float z = System.BitConverter.ToSingle(buf4, 0);                System.Array.Copy(tempall, index, buf4, 0, buf4.Length); index += buf4.Length;                float sz = System.BitConverter.ToSingle(buf4, 0);                ptcs[(pind) % ptcs.Length].position = new Vector3(x, y, z);                ptcs[(pind) % ptcs.Length].startSize = sz;                ptcs[(pind) % ptcs.Length].startColor = new Color32((byte)Random.Range(200, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(200, 255));                //Debug.Log("readEnvironment " + sz.ToString());                pind++;            }            ps.SetParticles(ptcs, ptcs.Length);            br.Close();            fs.Close();        }    }    void saveEnvironment()    {        string filepath = Application.dataPath + @"/StreamingAssets/" + Common.sceneName;		if (!Directory.Exists(filepath))        {// 文件夹                        Directory.CreateDirectory(filepath);        }		filepath += "/environment.ev";        if (File.Exists(filepath))        {            File.Delete(filepath);        }        FileStream fs = new FileStream(filepath, FileMode.Create);        BinaryWriter bw = new BinaryWriter(fs);        {// 保存粒子信息            ParticleSystem.Particle[] ptcs = new ParticleSystem.Particle[10];            PS.GetParticles(ptcs);            for (int i = 0; i < ptcs.Length; i++)            {                bw.Write(ptcs[i].position.x);                bw.Write(ptcs[i].position.y);                bw.Write(ptcs[i].position.z);                bw.Write(ptcs[i].startSize);                // bw.Write(ptcs[i].startColor);                //Debug.Log("saveEnvironment " + ptcs[i].startSize.ToString());            }        }    }    void Update()    {        {// 延后加载 星象            if(!bReadEnvironment && Time.time - loadtime > 2)            {                readEnvironment(PS);                bReadEnvironment = true;            }        }    }    // Use this for initialization    void Start()    {        loadobjs();           }    void OnApplicationQuit()    {		//#if UNITY_STANDALONE_WIN			saveEnvironment();			saveObjs();     		//#endif	    }}